# **Rev/Seed**
## **What is seed ?**
When referring to computer programming, security, or software, a random seed is a number or other value generated by software using one or more values. For example, hardware information, time, or date are different values that help generate a random value used by a program or encryption. 

### Python Random seed() Method


#### **Definition and Usage**
The seed() method is used to initialize the random number generator. By default the random number generator uses the current system time. Use the seed() method to customize the start number of the random number generator. In other words, `random()` function is used to generate random numbers in Python. Not actually random, rather this is used to generate pseudo-random numbers. That implies that these randomly generated numbers can be determined.

`random()` function generates numbers for some values. This value is also called seed value.

Seed function is used to save the state of a random function, so that it can generate same random numbers on multiple executions of the code on the same machine or on different machines (for a specific seed value). The seed value is the previous value number generated by the generator. For the first time when there is no previous value, it uses current system time.

#### **Syntax**

```
random.seed(a, version)
```

| Parameter  | Description  | 
| -------- | -------- |
| a     | Optional. The seed value needed to generate a random number. If it is an integer it is used directly, if not it has to be converted into an integer.Default value is None, and if None, the generator uses the current system time.     | 
| version     | An integer specifying how to convert the a parameter into a integer. Default value is 2     |


The random number generator needs a number to start with (a seed value), to be able to generate a random number.

**Example 1:**
```py
# random module is imported
import random 
for i in range(5):
  
    # Any number can be used in place of '0'.
    random.seed(0)
  
    # Generated random number will be between 1 to 1000.
    print(random.randint(1, 1000))  
```
**Output**
```
865
865
865
865
865
```

**Example 2:**
```py
# importing random module
import random
  
random.seed(3)
  
# print a random number between 1 and 1000.
print(random.randint(1, 1000))
  
# if you want to get the same random number again then,
random.seed(3) 
print(random.randint(1, 1000))
  
# If seed function is not used
  
# Gives totally unpredictable responses.
print(random.randint(1, 1000))
```
**Output**
```
244
244
607
```
On executing the above code, the above two print statements will generate a response 244 but the third print statement gives an unpredictable response.

1. This is used in the generation of a pseudo-random encryption key. Encryption keys are an important part of computer security. These are the kind of secret keys which used to protect data from unauthorized access over the internet.
2. It makes optimization of codes easy where random numbers are used for testing. The output of the code sometime depends on input. So the use of random numbers for testing algorithms can be complex. Also seed function is used to generate same random numbers again and again and simplifies algorithm testing process.

Here is further Examples in CTF's.

### **DamCTF (2021)**

#### **Description**
`seed.py` is the Python script used for generating the flag in this challenge. `log.txt` was the output from the script when the flag was generated.

#### **Review**

`seed.py` generated the flag by creating a bunch of sha256 hashes in a loop and then writing out the one with b9ff3ebf in the string as the flag:
```py
def seed():
    return round(time.time())

def hash(text):
    return hashlib.sha256(str(text).encode()).hexdigest()

def main():
    while True:
        s = seed()
        random.seed(s, version=2)

        x = random.random()
        flag = hash(x)

        if 'b9ff3ebf' in flag:
            with open("./flag", "w") as f:
                f.write(f"dam{{{flag}}}")
            f.close()
            break

        print(f"Incorrect: {x}")
    print("Good job <3")

if __name__ == "__main__":
   sys.exit(main())
```
**Output**
```
$ cat log.txt                            
Incorrect: 0.3322089622063289
Incorrect: 0.10859805708337256
Incorrect: 0.39751456956943265
Incorrect: 0.6194981263678604
Incorrect: 0.32054505821893853
Incorrect: 0.2674908181379442
Incorrect: 0.5379388350878211
Incorrect: 0.7799698997586163
Incorrect: 0.6893538761284775
Incorrect: 0.7171513961367021
Incorrect: 0.29362186264112344
Incorrect: 0.06571100672753238
Incorrect: 0.9607588522085679
Incorrect: 0.33534977507836194
Incorrect: 0.07384192274198853
Incorrect: 0.1448081453121044
Good job <3
```
The problem main is that the seed is based on time and rounded to the nearest integer:
```py
def seed():
    return round(time.time())
```
#### **Solution**

```
$ diff seed.py solve.py
```
```py
while True:
s = seed()

s = seed()
while s > 0:
s = s - 1
```
```
$ python3 ./solve.py
$ cat flag 
dam{f6f73f022249b67e0ff840c8635d95812bbb5437170464863eda8ba2b9ff3ebf}
```
